-- This script was generated by the Schema Diff utility in pgAdmin 4. 
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated 
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps. 
 BEGIN; 
   CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
 CREATE OR REPLACE FUNCTION public.enum_to_position(
	anyenum)
    RETURNS integer
    LANGUAGE 'sql'
    COST 100
    STABLE STRICT PARALLEL UNSAFE
AS $BODY$
SELECT enumpos::integer FROM (
        SELECT row_number() OVER (order by enumsortorder) AS enumpos,
               enumsortorder,
               enumlabel
        FROM pg_catalog.pg_enum
        WHERE enumtypid = pg_typeof($1)
    ) enum_ordering
    WHERE enumlabel = ($1::text);
$BODY$;

ALTER FUNCTION public.enum_to_position(anyenum)
    OWNER TO postgres;

CREATE SEQUENCE IF NOT EXISTS public.project_file_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.project_file_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.task_credentials_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.task_credentials_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.access_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.access_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.budget_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.budget_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.project_comments_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.project_comments_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.project_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.project_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.subtask_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.subtask_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.task_file_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.task_file_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.form_response_id
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.form_response_id
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.comments_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.comments_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.project_folder_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.project_folder_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.task_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.task_seq
    OWNER TO postgres;

-- Type: projecttype

-- DROP TYPE IF EXISTS public.projecttype;

CREATE TYPE public.projecttype AS ENUM
    ('default', 'internal', 'investment');

ALTER TYPE public.projecttype
    OWNER TO postgres;
-- Type: linktype

-- DROP TYPE IF EXISTS public.linktype;

CREATE TYPE public.linktype AS ENUM
    ('dao', 'clan', 'member');

ALTER TYPE public.linktype
    OWNER TO postgres;
-- Type: accesstype

-- DROP TYPE IF EXISTS public.accesstype;

CREATE TYPE public.accesstype AS ENUM
    ('hidden', 'view', 'create_task', 'manage_project');

ALTER TYPE public.accesstype
    OWNER TO postgres;
-- Type: visibilitytype

-- DROP TYPE IF EXISTS public.visibilitytype;

CREATE TYPE public.visibilitytype AS ENUM
    ('public', 'private');

ALTER TYPE public.visibilitytype
    OWNER TO postgres;
-- Type: commenttype

-- DROP TYPE IF EXISTS public.commenttype;

CREATE TYPE public.commenttype AS ENUM
    ('project', 'task');

ALTER TYPE public.commenttype
    OWNER TO postgres;
-- Type: enum_task_status

-- DROP TYPE IF EXISTS public.enum_task_status;

CREATE TYPE public.enum_task_status AS ENUM
    ('backlog', 'to-do', 'in-progress', 'in-review', 'done');

ALTER TYPE public.enum_task_status
    OWNER TO postgres;

CREATE TABLE IF NOT EXISTS public.project
(
    id bigint NOT NULL DEFAULT nextval('project_seq'::regclass),
    project_id uuid DEFAULT uuid_generate_v4(),
    description text COLLATE pg_catalog."default",
    title text COLLATE pg_catalog."default",
    visibility visibilitytype NOT NULL DEFAULT 'public'::visibilitytype,
    poc_member_id uuid,
    created_by uuid,
    discord_channel text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    link_id uuid,
    updated_by uuid,
    "default" boolean DEFAULT false,
    github_repos text[] COLLATE pg_catalog."default" DEFAULT '{}'::text[],
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    type linktype NOT NULL DEFAULT 'dao'::linktype,
    captain uuid,
    department uuid,
    notion_database text COLLATE pg_catalog."default",
    columns text COLLATE pg_catalog."default" DEFAULT '[]'::text,
    budget_amount numeric,
    budget_currency text COLLATE pg_catalog."default",
    completed boolean DEFAULT false,
    project_type projecttype DEFAULT 'default'::projecttype,
    total_col integer,
    pinned boolean DEFAULT false,
    CONSTRAINT project_pkey PRIMARY KEY (id),
    CONSTRAINT project_project_id_key UNIQUE (project_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.project
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.access
(
    id bigint NOT NULL DEFAULT nextval('access_seq'::regclass),
    project_id uuid,
    access accesstype,
    members uuid[] DEFAULT '{}'::uuid[],
    roles uuid[] DEFAULT '{}'::uuid[],
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    invite_link text COLLATE pg_catalog."default" DEFAULT substr(md5((random())::text), 0, 10),
    CONSTRAINT access_pkey PRIMARY KEY (id),
    CONSTRAINT access_invite_link_key UNIQUE (invite_link),
    CONSTRAINT project_id_fk FOREIGN KEY (project_id)
        REFERENCES public.project (project_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.access
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.folder
(
    id bigint NOT NULL DEFAULT nextval('project_folder_seq'::regclass),
    folder_id uuid DEFAULT uuid_generate_v4(),
    name text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    project_id uuid,
    description text COLLATE pg_catalog."default",
    created_by uuid,
    updated_by uuid,
    CONSTRAINT project_folder_pkey PRIMARY KEY (id),
    CONSTRAINT project_folder_folder_id_key UNIQUE (folder_id),
    CONSTRAINT project_id_fk FOREIGN KEY (project_id)
        REFERENCES public.project (project_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.folder
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.project_files
(
    id bigint NOT NULL DEFAULT nextval('project_file_seq'::regclass),
    project_file_id uuid DEFAULT uuid_generate_v4(),
    name text COLLATE pg_catalog."default",
    url text COLLATE pg_catalog."default",
    metadata json NOT NULL DEFAULT '{}'::json,
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    folder_id uuid,
    CONSTRAINT project_files_pkey PRIMARY KEY (id),
    CONSTRAINT project_files_file_id_key UNIQUE (project_file_id),
    CONSTRAINT folder_id_fk FOREIGN KEY (folder_id)
        REFERENCES public.folder (folder_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.project_files
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.task
(
    id bigint NOT NULL DEFAULT nextval('task_seq'::regclass),
    task_id uuid DEFAULT uuid_generate_v4(),
    title text COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    poc_member_id uuid,
    deadline timestamp without time zone,
    created_by uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    updated_by uuid,
    assignee_member uuid[] DEFAULT '{}'::uuid[],
    project_id uuid,
    tags text[] COLLATE pg_catalog."default" DEFAULT '{}'::text[],
    feedback text COLLATE pg_catalog."default",
    assignee_clan uuid[] DEFAULT '{}'::uuid[],
    github_issue integer DEFAULT 0,
    "position" double precision NOT NULL,
    notion_page text COLLATE pg_catalog."default",
    notion_property text COLLATE pg_catalog."default",
    col integer NOT NULL,
    payout text COLLATE pg_catalog."default" DEFAULT '[]'::text,
    payment_created boolean DEFAULT false,
    github_pr text COLLATE pg_catalog."default",
    archived boolean DEFAULT false,
    CONSTRAINT task_pkey PRIMARY KEY (id),
    CONSTRAINT task_task_id_key UNIQUE (task_id),
    CONSTRAINT project_id_fk FOREIGN KEY (project_id)
        REFERENCES public.project (project_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.task
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.comments
(
    id bigint NOT NULL DEFAULT nextval('comments_seq'::regclass),
    link_id uuid,
    body text COLLATE pg_catalog."default",
    author uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    type commenttype NOT NULL,
    tagged_members uuid[] DEFAULT '{}'::uuid[],
    CONSTRAINT comments_pkey PRIMARY KEY (id),
    CONSTRAINT task_fk FOREIGN KEY (link_id)
        REFERENCES public.task (task_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.comments
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.tasks_files
(
    id bigint NOT NULL DEFAULT nextval('task_file_seq'::regclass),
    task_file_id uuid DEFAULT uuid_generate_v4(),
    task_id uuid,
    name text COLLATE pg_catalog."default",
    url text COLLATE pg_catalog."default",
    metadata json DEFAULT '{}'::json,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT tasks_files_pkey PRIMARY KEY (id),
    CONSTRAINT task_id_fk FOREIGN KEY (task_id)
        REFERENCES public.task (task_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.tasks_files
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.form_response
(
    id bigint NOT NULL DEFAULT nextval('form_response_id'::regclass),
    response_id uuid DEFAULT uuid_generate_v4(),
    project_id uuid,
    response_type text COLLATE pg_catalog."default",
    mongo_object text COLLATE pg_catalog."default",
    title text COLLATE pg_catalog."default",
    col integer DEFAULT 1,
    "position" double precision,
    assignee_member uuid[] DEFAULT '{}'::uuid[],
    assignee_clan uuid[] DEFAULT '{}'::uuid[],
    created_at timestamp without time zone DEFAULT now(),
    updated_by uuid,
    updated_at timestamp without time zone,
    discussion_id uuid,
    CONSTRAINT form_response_pkey PRIMARY KEY (id),
    CONSTRAINT form_response_response_id_key UNIQUE (response_id),
    CONSTRAINT project_id_fk FOREIGN KEY (project_id)
        REFERENCES public.project (project_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.form_response
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.subtask
(
    id bigint NOT NULL DEFAULT nextval('subtask_seq'::regclass),
    subtask_id uuid DEFAULT uuid_generate_v4(),
    task_id uuid,
    title text COLLATE pg_catalog."default" NOT NULL,
    completed boolean NOT NULL DEFAULT false,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT subtask_pkey PRIMARY KEY (id),
    CONSTRAINT subtask_subtask_id_key UNIQUE (subtask_id),
    CONSTRAINT task_id FOREIGN KEY (task_id)
        REFERENCES public.task (task_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.subtask
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.task_credentials
(
    id bigint NOT NULL DEFAULT nextval('task_credentials_seq'::regclass),
    member_id uuid,
    task_id uuid,
    claim boolean,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT task_credentials_pkey PRIMARY KEY (id),
    CONSTRAINT task_id_fk FOREIGN KEY (task_id)
        REFERENCES public.task (task_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.task_credentials
    OWNER to postgres;

CREATE OR REPLACE VIEW public.tags
 AS
 SELECT DISTINCT unnest(task.tags) AS tag,
    count(*) AS count
   FROM task
  GROUP BY (unnest(task.tags))
  ORDER BY (count(*)) DESC;

ALTER TABLE public.tags
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.member_assigned
 AS
 SELECT p.project_id,
    t.task_id,
    unnest(t.assignee_member) AS member_id
   FROM project p
     JOIN task t ON p.project_id = t.project_id;

ALTER TABLE public.member_assigned
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.task_view
 AS
 SELECT t.task_id,
    t.project_id,
    t.title,
    t.description,
    t.created_by,
    t.updated_by,
    t.poc_member_id,
    t.notion_page,
    t.tags,
    t.deadline,
    t.assignee_member,
    t.assignee_clan,
    t.feedback,
    t."position",
    t.created_at,
    t.updated_at,
    t.github_issue,
    t.github_pr,
    to_json(ARRAY( SELECT json_build_object('task_file_id', tf.task_file_id, 'task_id', tf.task_id, 'name', tf.name, 'url', tf.url, 'metadata', tf.metadata) AS file
           FROM tasks_files tf
          WHERE tf.task_id = t.task_id)) AS files,
    to_json(ARRAY( SELECT json_build_object('subtask_id', subtask.subtask_id, 'title', subtask.title, 'completed', subtask.completed) AS subtask
           FROM subtask
          WHERE subtask.task_id = t.task_id)) AS subtasks,
    to_json(ARRAY( SELECT json_build_object('comment_id', comments.id, 'link_id', comments.link_id, 'body', comments.body, 'author', comments.author, 'type', comments.type) AS comment
           FROM comments
          WHERE comments.link_id = t.task_id)) AS comments,
    t.col,
    t.payout,
    t.payment_created,
    ARRAY( SELECT tc.member_id
           FROM task_credentials tc
          WHERE tc.task_id = t.task_id) AS vc_claim,
    t.archived
   FROM task t;

ALTER TABLE public.task_view
    OWNER TO postgres;



 END;