-- This script was generated by the Schema Diff utility in pgAdmin 4. 
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated 
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps. 
 BEGIN; 
 CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
 -- Type: invitestatus

-- DROP TYPE IF EXISTS public.invitestatus;

CREATE TYPE public.invitestatus AS ENUM
    ('pending', 'accepted', 'rejected');

ALTER TYPE public.invitestatus
    OWNER TO postgres;
-- Type: chaintype

-- DROP TYPE IF EXISTS public.chaintype;

CREATE TYPE public.chaintype AS ENUM
    ('mainnet', 'testnet');

ALTER TYPE public.chaintype
    OWNER TO postgres;
-- Type: visibilitytype

-- DROP TYPE IF EXISTS public.visibilitytype;

CREATE TYPE public.visibilitytype AS ENUM
    ('public', 'private');

ALTER TYPE public.visibilitytype
    OWNER TO postgres;
-- Type: accesstype

-- DROP TYPE IF EXISTS public.accesstype;

CREATE TYPE public.accesstype AS ENUM
    ('hidden', 'view', 'create_task', 'manage_project', 'manage_dao');

ALTER TYPE public.accesstype
    OWNER TO postgres;
 CREATE OR REPLACE FUNCTION public.enum_to_position(
	anyenum)
    RETURNS integer
    LANGUAGE 'sql'
    COST 100
    STABLE STRICT PARALLEL UNSAFE
AS $BODY$
SELECT enumpos::integer FROM (
        SELECT row_number() OVER (order by enumsortorder) AS enumpos,
               enumsortorder,
               enumlabel
        FROM pg_catalog.pg_enum
        WHERE enumtypid = pg_typeof($1)
    ) enum_ordering
    WHERE enumlabel = ($1::text);
$BODY$;

ALTER FUNCTION public.enum_to_position(anyenum)
    OWNER TO postgres;

CREATE SEQUENCE IF NOT EXISTS public.daoid_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.daoid_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.blogs_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.blogs_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.analytics_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.analytics_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.access_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.access_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.provider_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.provider_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.discord_analytics_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.discord_analytics_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.dao_invites_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.dao_invites_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.social_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.social_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.events_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.events_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.chain_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.chain_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.department__seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.department__seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.collaboration_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.collaboration_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.dao_partner_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.dao_partner_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.partner_social_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.partner_social_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.dao_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.dao_id_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.token_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.token_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.user_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.user_id_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.reviews_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.reviews_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.favourite_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.favourite_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.member_role_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.member_role_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.token_gating_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.token_gating_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.dao_role_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.dao_role_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.dao_member_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

CREATE TABLE IF NOT EXISTS public.dao
(
    id bigint NOT NULL DEFAULT nextval('dao_id_seq'::regclass),
    dao_id uuid DEFAULT uuid_generate_v4(),
    name text COLLATE pg_catalog."default",
    guild_id text COLLATE pg_catalog."default",
    about text COLLATE pg_catalog."default",
    profile_picture text COLLATE pg_catalog."default",
    contract_address text COLLATE pg_catalog."default",
    snapshot text COLLATE pg_catalog."default",
    owner_id uuid DEFAULT uuid_nil(),
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    onboarding boolean DEFAULT false,
    dao_type text COLLATE pg_catalog."default" DEFAULT 'general'::text,
    token_gating boolean DEFAULT false,
    CONSTRAINT dao_pkey PRIMARY KEY (id),
    CONSTRAINT dao_guild_id_key UNIQUE (guild_id),
    CONSTRAINT dao_user_id_key UNIQUE (dao_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.dao
    OWNER to postgres;
	

CREATE TABLE IF NOT EXISTS public.roles
(
    id bigint NOT NULL DEFAULT nextval('dao_role_seq'::regclass),
    name text COLLATE pg_catalog."default",
    dao_id uuid,
    role_id uuid DEFAULT uuid_generate_v4(),
    discord_role_id text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT dao_role_pkey PRIMARY KEY (id),
    CONSTRAINT dao_role_role_id_key UNIQUE (role_id),
    CONSTRAINT doa_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.roles
    OWNER to postgres;
	
ALTER SEQUENCE public.dao_member_seq
    OWNER TO postgres;
CREATE TABLE IF NOT EXISTS public.provider
(
    id bigint NOT NULL DEFAULT nextval('provider_seq'::regclass),
    dao_id uuid,
    provider_type text COLLATE pg_catalog."default",
    address text COLLATE pg_catalog."default",
    created_by uuid,
    chain_id integer,
    is_default boolean,
    name text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT provider_pkey PRIMARY KEY (id),
    CONSTRAINT dao_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.provider
    OWNER to postgres;

COMMENT ON COLUMN public.provider.provider_type
    IS 'enum - gnosis, wallet, parcel';

COMMENT ON COLUMN public.provider.chain_id
    IS 'from frontend';
CREATE TABLE IF NOT EXISTS public.members
(
    id bigint NOT NULL DEFAULT nextval('dao_member_seq'::regclass),
    dao_id uuid,
    member_id uuid,
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    CONSTRAINT dao_member_pkey PRIMARY KEY (id),
    CONSTRAINT doa_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.members
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.dao_invites
(
    id bigint NOT NULL DEFAULT nextval('dao_invites_seq'::regclass),
    dao_id uuid,
    created_by uuid,
    invite_code text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    valid_until timestamp without time zone,
    CONSTRAINT dao_invites_pkey PRIMARY KEY (id),
    CONSTRAINT dao_invites_invite_code_key UNIQUE (invite_code),
    CONSTRAINT dao_invites_dao_id_fkey FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.dao_invites
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.access
(
    id bigint NOT NULL DEFAULT nextval('access_seq'::regclass),
    dao_id uuid,
    access accesstype,
    roles uuid[] DEFAULT '{}'::uuid[],
    members uuid[] DEFAULT '{}'::uuid[],
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT access_pkey PRIMARY KEY (id),
    CONSTRAINT dao_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.access
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.blogs
(
    id bigint NOT NULL DEFAULT nextval('blogs_seq'::regclass),
    dao_id uuid,
    link text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    metadata json,
    CONSTRAINT blogs_pkey PRIMARY KEY (id),
    CONSTRAINT dao_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.blogs
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.member_roles
(
    id bigint NOT NULL DEFAULT nextval('member_role_seq'::regclass),
    dao_id uuid,
    member_id uuid,
    role_id uuid,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT member_roles_pkey PRIMARY KEY (id),
    CONSTRAINT dao_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT role_id_fk FOREIGN KEY (role_id)
        REFERENCES public.roles (role_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;
ALTER TABLE IF EXISTS public.member_roles
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.analytics
(
    id bigint NOT NULL DEFAULT nextval('analytics_seq'::regclass),
    dao_id uuid,
    member_id uuid,
    "time" timestamp without time zone DEFAULT now(),
    visitor_ip text COLLATE pg_catalog."default",
    CONSTRAINT analytics_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.analytics
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.discord_analytics
(
    id bigint NOT NULL DEFAULT nextval('discord_analytics_seq'::regclass),
    dao_id uuid,
    member_count bigint,
    created_at timestamp without time zone DEFAULT now(),
    guild_id text COLLATE pg_catalog."default",
    CONSTRAINT discord_analytics_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.discord_analytics
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.department
(
    id bigint NOT NULL DEFAULT nextval('department__seq'::regclass),
    department_id uuid DEFAULT uuid_generate_v4(),
    dao_id uuid,
    name text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT department_pkey PRIMARY KEY (id),
    CONSTRAINT department_department_id_key UNIQUE (department_id),
    CONSTRAINT dao_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.department
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.social
(
    id bigint NOT NULL DEFAULT nextval('social_seq'::regclass),
    dao_id uuid,
    type text COLLATE pg_catalog."default",
    url text COLLATE pg_catalog."default",
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT social_pkey1 PRIMARY KEY (id),
    CONSTRAINT dao_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.social
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.favourite
(
    id bigint NOT NULL DEFAULT nextval('favourite_seq'::regclass),
    dao_id uuid,
    member_id uuid,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT favourite_pkey PRIMARY KEY (id),
    CONSTRAINT dao_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.favourite
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.dao_partner
(
    id bigint NOT NULL DEFAULT nextval('dao_partner_seq'::regclass),
    dao_partner_id uuid DEFAULT uuid_generate_v4(),
    name text COLLATE pg_catalog."default",
    logo text COLLATE pg_catalog."default",
    website text COLLATE pg_catalog."default",
    email text COLLATE pg_catalog."default",
    phone text COLLATE pg_catalog."default",
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    updated_at timestamp without time zone,
    dao_id uuid,
    CONSTRAINT dao_partner_pkey PRIMARY KEY (id),
    CONSTRAINT dao_partner_daoid_key UNIQUE (dao_partner_id),
    CONSTRAINT doa_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.dao_partner
    OWNER to postgres;
	
CREATE TABLE IF NOT EXISTS public.partner_social
(
    id bigint NOT NULL DEFAULT nextval('partner_social_seq'::regclass),
    dao_partner_id uuid,
    type text COLLATE pg_catalog."default",
    url text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT social_pkey PRIMARY KEY (id),
    CONSTRAINT doa_partner_id FOREIGN KEY (dao_partner_id)
        REFERENCES public.dao_partner (dao_partner_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.partner_social
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.reviews
(
    id bigint NOT NULL DEFAULT nextval('reviews_seq'::regclass),
    dao_id uuid,
    member_id uuid NOT NULL,
    content text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    rating integer,
    CONSTRAINT reviews_pkey PRIMARY KEY (id),
    CONSTRAINT dao_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.reviews
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.collaboration
(
    id bigint NOT NULL DEFAULT nextval('collaboration_seq'::regclass),
    collaboration_id uuid DEFAULT uuid_generate_v4(),
    applying_member_id uuid NOT NULL,
    from_dao_id uuid,
    to_dao_id uuid,
    status text COLLATE pg_catalog."default",
    title text COLLATE pg_catalog."default",
    department uuid,
    description text COLLATE pg_catalog."default",
    requirements json DEFAULT '{}'::json,
    benefits text COLLATE pg_catalog."default",
    attachment text COLLATE pg_catalog."default",
    replying_member_id uuid NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT collaboration_pkey PRIMARY KEY (id),
    CONSTRAINT collaboration_collaboration_id_key UNIQUE (collaboration_id),
    CONSTRAINT department_id_fk FOREIGN KEY (department)
        REFERENCES public.department (department_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT from_dao_id_fk FOREIGN KEY (from_dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT to_dao_id_fk FOREIGN KEY (to_dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.collaboration
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.token
(
    id bigint NOT NULL DEFAULT nextval('token_seq'::regclass),
    dao_id uuid,
    ticker text COLLATE pg_catalog."default",
    contract_address text COLLATE pg_catalog."default",
    average_time_held text COLLATE pg_catalog."default",
    updated_at timestamp without time zone,
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    holders integer,
    CONSTRAINT token_pkey PRIMARY KEY (id),
    CONSTRAINT doa_id_fk FOREIGN KEY (dao_id)
        REFERENCES public.dao (dao_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.token
    OWNER to postgres;

CREATE OR REPLACE VIEW public.dao_view
 AS
 SELECT d.dao_id,
    d.name,
    d.about,
    d.profile_picture,
    d.contract_address,
    d.snapshot,
    d.owner_id,
    d.created_at,
    d.updated_at,
    ARRAY( SELECT dm.member_id
           FROM members dm
          WHERE dm.dao_id = d.dao_id) AS members,
    to_json(ARRAY( SELECT json_build_object('role_id', dr.role_id, 'name', dr.name) AS role
           FROM roles dr
          WHERE dr.dao_id = d.dao_id)) AS roles,
    to_json(ARRAY( SELECT json_build_object('department_id', dp.department_id, 'name', dp.name) AS department
           FROM department dp
          WHERE dp.dao_id = d.dao_id)) AS departments,
    to_json(ARRAY( SELECT json_build_object('id', s.id, 'type', s.type, 'url', s.url) AS social
           FROM social s
          WHERE s.dao_id = d.dao_id)) AS socials,
    to_json(ARRAY( SELECT json_build_object('id', t.id, 'ticker', t.ticker, 'contract_address', t.contract_address, 'average_time_held', t.average_time_held, 'holders', t.holders) AS token
           FROM token t
          WHERE t.dao_id = d.dao_id)) AS tokens,
    d.guild_id,
    d.onboarding,
    d.token_gating,
    d.dao_type
   FROM dao d;

ALTER TABLE public.dao_view
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.members_view
 AS
 SELECT m.member_id,
    d.dao_id,
    d.name,
    d.about,
    d.guild_id,
    d.profile_picture,
    d.owner_id,
    to_json(ARRAY( SELECT json_build_object('dao_id', dr.dao_id, 'role_id', dr.role_id, 'name', dr.name, 'discord_role_id', dr.discord_role_id) AS role
           FROM roles dr
             JOIN member_roles mr ON dr.role_id = mr.role_id
          WHERE mr.member_id = m.member_id AND mr.dao_id = d.dao_id)) AS roles,
    COALESCE(( SELECT a.access
           FROM access a
             JOIN member_roles mr ON m.member_id = mr.member_id
             JOIN roles dr ON dr.role_id = mr.role_id
          WHERE a.dao_id = d.dao_id AND ((m.member_id = ANY (a.members)) OR (dr.role_id = ANY (a.roles)))
          ORDER BY (a.access) DESC
         LIMIT 1), 'view'::accesstype) AS access,
    d.created_at AS dao_created,
    d.updated_at AS dao_updated,
    d.onboarding,
    d.snapshot,
    d.dao_type,
    m.created_at AS member_joined,
    d.token_gating
   FROM members m
     JOIN dao d ON d.dao_id = m.dao_id;

ALTER TABLE public.members_view
    OWNER TO postgres;



 END;