-- This script was generated by the Schema Diff utility in pgAdmin 4. 
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated 
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps. 
 BEGIN; 
  CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
 CREATE SEQUENCE IF NOT EXISTS public.members_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.members_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.clan_invites_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.clan_invites_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.reviews_id
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.reviews_id
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.member_wallet_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.member_wallet_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.discord_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.discord_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.social_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.social_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.skill_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.skill_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.members_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.members_id_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.rewards_earned_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.rewards_earned_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.chain_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.chain_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.connections_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.connections_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.onboarding_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.onboarding_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.clan_member_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.clan_member_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.clan_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.clan_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.addresss_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE public.addresss_id_seq
    OWNER TO postgres;

-- Type: chaintype

-- DROP TYPE IF EXISTS public.chaintype;

CREATE TYPE public.chaintype AS ENUM
    ('mainnet', 'testnet');

ALTER TYPE public.chaintype
    OWNER TO postgres;
-- Type: chainnetwork

-- DROP TYPE IF EXISTS public.chainnetwork;

CREATE TYPE public.chainnetwork AS ENUM
    ('EVM', 'SOLANA');

ALTER TYPE public.chainnetwork
    OWNER TO postgres;
-- Type: invitestatus

-- DROP TYPE IF EXISTS public.invitestatus;

CREATE TYPE public.invitestatus AS ENUM
    ('revoked', 'pending', 'accepted', 'rejected');

ALTER TYPE public.invitestatus
    OWNER TO postgres;

CREATE TABLE IF NOT EXISTS public.members
(
    id bigint NOT NULL DEFAULT nextval('members_seq'::regclass),
    member_id uuid DEFAULT uuid_generate_v4(),
    name text COLLATE pg_catalog."default",
    phone text COLLATE pg_catalog."default",
    email text COLLATE pg_catalog."default",
    about text COLLATE pg_catalog."default",
    skills text[] COLLATE pg_catalog."default" NOT NULL DEFAULT '{}'::text[],
    profile_picture text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    did text COLLATE pg_catalog."default" NOT NULL,
    username text COLLATE pg_catalog."default",
    captain boolean DEFAULT false,
    open_for_opportunity boolean DEFAULT true,
    ceramic_stream text COLLATE pg_catalog."default",
    subdomain text COLLATE pg_catalog."default",
    invite_code text COLLATE pg_catalog."default" DEFAULT substr(md5((random())::text), 0, 8),
    CONSTRAINT members_pkey PRIMARY KEY (id),
    CONSTRAINT members_email_key UNIQUE (email),
    CONSTRAINT members_invite_code_key UNIQUE (invite_code),
    CONSTRAINT members_member_id_key UNIQUE (member_id),
    CONSTRAINT members_username_key UNIQUE (username)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.members
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.onboarding
(
    id bigint NOT NULL DEFAULT nextval('onboarding_seq'::regclass),
    member_id uuid,
    admin boolean,
    contributor boolean,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    invite_code text COLLATE pg_catalog."default",
    CONSTRAINT onboarding_pkey PRIMARY KEY (id),
    CONSTRAINT member_id_fk FOREIGN KEY (member_id)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.onboarding
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.clans
(
    id bigint NOT NULL DEFAULT nextval('clan_seq'::regclass),
    clan_id uuid DEFAULT uuid_generate_v4(),
    name text COLLATE pg_catalog."default",
    visibility text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    avatar text COLLATE pg_catalog."default",
    created_by uuid,
    CONSTRAINT clans_pkey PRIMARY KEY (id),
    CONSTRAINT clans_clan_id_key UNIQUE (clan_id),
    CONSTRAINT clans_name_key UNIQUE (name),
    CONSTRAINT created_by_fk FOREIGN KEY (created_by)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.clans
    OWNER to postgres;


CREATE INDEX IF NOT EXISTS invite_code_idx
    ON public.onboarding USING btree
    (invite_code COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.clan_invites
(
    id bigint NOT NULL DEFAULT nextval('clan_invites_seq'::regclass),
    clan_id uuid,
    sender_id uuid,
    invite_code text COLLATE pg_catalog."default",
    receiver_id uuid,
    status invitestatus,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT clan_invites_pkey PRIMARY KEY (id),
    CONSTRAINT clan_invites_invite_code_key UNIQUE (invite_code),
    CONSTRAINT clan_id_fk FOREIGN KEY (clan_id)
        REFERENCES public.clans (clan_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT receiver_member_id_fk FOREIGN KEY (receiver_id)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT sender_member_id_fk FOREIGN KEY (sender_id)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.clan_invites
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.discord
(
    id bigint NOT NULL DEFAULT nextval('discord_seq'::regclass),
    member_id uuid DEFAULT uuid_generate_v4(),
    discord_user_id text COLLATE pg_catalog."default" NOT NULL,
    username text COLLATE pg_catalog."default",
    avatar text COLLATE pg_catalog."default",
    discriminator text COLLATE pg_catalog."default",
    public_flags integer,
    flags integer,
    banner text COLLATE pg_catalog."default",
    banner_color text COLLATE pg_catalog."default",
    accent_color integer,
    locale text COLLATE pg_catalog."default",
    mfa_enabled boolean,
    verified boolean,
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    updated_at timestamp without time zone,
    email text COLLATE pg_catalog."default",
    CONSTRAINT discord_pkey PRIMARY KEY (id),
    CONSTRAINT discord_discord_member_id_key UNIQUE (discord_user_id),
    CONSTRAINT member_id_fk FOREIGN KEY (member_id)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.discord
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.rewards_earned
(
    id bigint NOT NULL DEFAULT nextval('rewards_earned_seq'::regclass),
    member_id uuid NOT NULL,
    dao_id uuid NOT NULL,
    amount numeric NOT NULL DEFAULT 0.0,
    currency text COLLATE pg_catalog."default" NOT NULL,
    link_id uuid NOT NULL,
    type text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT rewards_earned_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.rewards_earned
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.member_wallet
(
    id bigint NOT NULL DEFAULT nextval('member_wallet_seq'::regclass),
    member_id uuid,
    wallet_address text COLLATE pg_catalog."default" NOT NULL,
    "default" boolean DEFAULT false,
    chain_id bigint NOT NULL,
    CONSTRAINT member_wallet_pkey PRIMARY KEY (id),
    CONSTRAINT member_wallet_wallet_address_key UNIQUE (wallet_address),
    CONSTRAINT member_id_fk FOREIGN KEY (member_id)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.member_wallet
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.social
(
    id bigint NOT NULL DEFAULT nextval('social_seq'::regclass),
    member_id uuid,
    type text COLLATE pg_catalog."default",
    url text COLLATE pg_catalog."default",
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT social_pkey PRIMARY KEY (id),
    CONSTRAINT member_id_fk FOREIGN KEY (member_id)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.social
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.reviews
(
    id bigint NOT NULL DEFAULT nextval('reviews_id'::regclass),
    member_id uuid,
    reviewer_id uuid NOT NULL,
    content text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    rating integer,
    CONSTRAINT reviews_pkey PRIMARY KEY (id),
    CONSTRAINT member_id_fk FOREIGN KEY (reviewer_id)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT reviews_member_id_fkey FOREIGN KEY (member_id)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.reviews
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.clan_members
(
    id bigint NOT NULL DEFAULT nextval('clan_member_seq'::regclass),
    clan_id uuid,
    member_id uuid,
    role text COLLATE pg_catalog."default",
    notification boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT clan_members_pkey PRIMARY KEY (id),
    CONSTRAINT clan_id_fk FOREIGN KEY (clan_id)
        REFERENCES public.clans (clan_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT member_id_fk FOREIGN KEY (member_id)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.clan_members
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.connection_request
(
    id bigint NOT NULL DEFAULT nextval('connections_seq'::regclass),
    sender_id uuid,
    receiver_id uuid,
    status invitestatus,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT connections_pkey PRIMARY KEY (id),
    CONSTRAINT receiver_id_fk FOREIGN KEY (receiver_id)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT sender_id_fk FOREIGN KEY (sender_id)
        REFERENCES public.members (member_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.connection_request
    OWNER to postgres;

CREATE OR REPLACE VIEW public.skills
 AS
 SELECT DISTINCT unnest(members.skills) AS skill,
    count(*) AS count
   FROM members
  GROUP BY (unnest(members.skills))
  ORDER BY (count(*)) DESC;

ALTER TABLE public.skills
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.clan_view
 AS
 SELECT c.clan_id,
    c.name,
    c.visibility,
    c.avatar,
    c.created_by,
    c.created_at,
    c.updated_at,
    to_json(ARRAY( SELECT json_build_object('member_id', cm.member_id, 'username', m.username, 'profile_picture', m.profile_picture, 'role', cm.role, 'notification', cm.notification) AS json_build_object
           FROM clan_members cm
             JOIN members m ON cm.member_id = m.member_id
          WHERE cm.clan_id = c.clan_id
          ORDER BY cm.created_at DESC)) AS members
   FROM clans c;

ALTER TABLE public.clan_view
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.member_view
 AS
 SELECT m.member_id,
    m.name,
    m.phone,
    COALESCE(m.email, d.email, ''::text) AS email,
    m.about,
    m.did,
    m.skills,
    to_json(ARRAY( SELECT json_build_object('wallet_id', mw_1.id, 'wallet_address', mw_1.wallet_address, 'chain_id', mw_1.chain_id, 'default', mw_1."default") AS wallet
           FROM member_wallet mw_1
          WHERE m.member_id = mw_1.member_id)) AS wallets,
    json_build_object('discord_user_id', d.discord_user_id, 'username', d.username, 'avatar', d.avatar, 'discriminator', d.discriminator, 'flags', d.flags, 'locale', d.locale, 'verified', d.verified, 'email', d.email) AS discord,
    m.created_at,
    m.updated_at,
    m.username,
    m.captain,
    m.open_for_opportunity,
    m.profile_picture,
    m.ceramic_stream,
    json_build_object('wallet_id', mw.id, 'member_id', mw.member_id, 'wallet_address', mw.wallet_address, 'chain_id', mw.chain_id, 'default', mw."default") AS default_wallet,
    mw.wallet_address AS default_wallet_address,
    m.subdomain,
    m.invite_code,
    ( SELECT sum(
                CASE o_1.admin OR o_1.contributor
                    WHEN true THEN 1
                    ELSE 0
                END) AS count
           FROM onboarding o_1
          WHERE o_1.invite_code = m.invite_code) AS invite_count,
    o.admin OR o.contributor AS onboarding
   FROM members m
     LEFT JOIN discord d ON d.member_id = m.member_id
     JOIN member_wallet mw ON mw.member_id = m.member_id
     JOIN onboarding o ON o.member_id = m.member_id
  WHERE mw."default" = true;

ALTER TABLE public.member_view
    OWNER TO postgres;



 END;